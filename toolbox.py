import zipfile
import os
import re
import html
import webvtt
import pypandoc
import chardet
import tempfile
import ass
import pysrt
import datetime
from template import MarkdownTemplate, HTMLTemplate
from DrissionPage import ChromiumPage, ChromiumOptions
import requests
from rich.progress import Progress, BarColumn
from rich.console import Console
import argparse
import json
from collections import defaultdict
from opencc import OpenCC
import filecmp

cc = OpenCC("s2t")

banner = r"""
[blue]
   __________    ___  ____  _  __
  / __/_  __/___/ _ )/ __ \| |/_/
 _\ \  / / /___/ _  / /_/ />  <  
/___/ /_/     /____/\____/_/|_|  

[/blue]                                                                               
[red][b]Stand-up subtitles toolbox v1.0[/b][/red]
[green]author: @xifan[/green]

"""


class Toolbox:
    def __init__(self):
        self.chrome_path = "tools/chrome/chrome.exe"
        self.pandoc_path = "tools/pandoc/pandoc.exe"
        self.template_path = "templates"
        self.api_key = "4d81bcbc939fae61654a32969f4ca989"
        os.environ["PATH"] += os.pathsep + self.pandoc_path
        os.environ["PATH"] += os.pathsep + self.chrome_path
        self.console = Console()
        self.progress = Progress(
            "[progress.description]{task.description}",
            BarColumn(),
            "[progress.percentage]{task.percentage:>3.0f}%",
            "‚Ä¢",
            "[progress.completed]{task.completed}/{task.total}",
            "{task.fields[filename]}",
            console=self.console,
        )
        self.task_states = {}
        self.batch_mode = False

    def save_task_state(self, task_id, completed_files):
        self.task_states[task_id] = completed_files
        with open("task_states.json", "w") as f:
            json.dump(self.task_states, f)

    def load_task_state(self, task_id):
        try:
            with open("task_states.json", "r") as f:
                self.task_states = json.load(f)
            return self.task_states.get(task_id, [])
        except FileNotFoundError:
            self.console.print("[red]Êú™ÊâæÂà∞‰ªªÂä°Áä∂ÊÄÅÊñá‰ª∂[/red]")
            return []

    def batch_unzip(self, zip_files, output_folder, resume=False):
        self.batch_mode = True
        task_id = "unzip"
        completed_files = self.load_task_state(task_id) if resume else []

        with self.progress:
            task = self.progress.add_task(
                "[green]üì¶ Ëß£ÂéãÁº©...", total=len(zip_files), filename=""
            )

            for zip_file in zip_files:
                self.progress.update(
                    task, filename=f"Ê≠£Âú®Â§ÑÁêÜ: {os.path.basename(zip_file)}"
                )
                if zip_file in completed_files:
                    self.progress.advance(task)
                    continue

                if self.unzip(zip_file, output_folder):
                    completed_files.append(zip_file)
                    self.save_task_state(task_id, completed_files)

                self.progress.advance(task)
        self.batch_mode = False

    def batch_convert(self, source_files, target_path, _format, resume=False):
        self.batch_mode = True
        task_id = f"convert_{_format}"
        completed_files = self.load_task_state(task_id) if resume else []

        with self.progress:
            task = self.progress.add_task(
                f"[blue]üîÑ ËΩ¨Êç¢‰∏∫ {_format}...", total=len(source_files), filename=""
            )

            for source_file in source_files:
                self.progress.update(
                    task, filename=f"Ê≠£Âú®Â§ÑÁêÜ: {os.path.basename(source_file)}"
                )
                if source_file in completed_files:
                    self.progress.advance(task)
                    continue

                self.convert(source_file, target_path, _format)
                completed_files.append(source_file)
                self.save_task_state(task_id, completed_files)

                self.progress.advance(task)
        self.batch_mode = False

    def batch_rename(self, input_paths, resume=False):
        self.batch_mode = True
        task_id = "rename"
        completed_files = self.load_task_state(task_id) if resume else []
        files_to_rename = []

        for input_path in input_paths:
            if os.path.isdir(input_path):
                files_to_rename.extend(
                    [
                        os.path.join(input_path, f)
                        for f in os.listdir(input_path)
                        if f.endswith((".vtt", ".srt", ".ass"))
                    ]
                )
            elif os.path.isfile(input_path) and input_path.endswith(
                (".vtt", ".srt", ".ass")
            ):
                files_to_rename.append(input_path)

        with self.progress:
            task = self.progress.add_task(
                "[cyan]‚úèÔ∏è ÈáçÂëΩÂêç...", total=len(files_to_rename), filename=""
            )

            for file in files_to_rename:
                self.progress.update(
                    task, filename=f"Ê≠£Âú®Â§ÑÁêÜ: {os.path.basename(file)}"
                )
                if file in completed_files:
                    self.progress.advance(task)
                    continue

                self.rename(file)
                completed_files.append(file)
                self.save_task_state(task_id, completed_files)

                self.progress.advance(task)
        self.batch_mode = False

    def diff(self, source_folder, target_folder, _format, resume=False):
        self.batch_mode = True
        task_id = "diff"
        completed_files = self.load_task_state(task_id) if resume else []

        dcmp = filecmp.dircmp(source_folder, target_folder)
        missing_files = [
            file for file in dcmp.left_only if file.endswith((".vtt", ".srt", ".ass"))
        ]

        if missing_files:
            self.console.print("[yellow][b]üìã ‰ª•‰∏ãÊñá‰ª∂Âú®ÁõÆÊ†áÁõÆÂΩï‰∏≠Áº∫Â§±:[/b][/yellow]")
            for file in missing_files:
                if file in completed_files:
                    self.console.print(f"[blue]{file}[/blue] [green]‚úîÔ∏è[/green]")
                else:
                    self.console.print(f"[yellow]{file}[/yellow] [red]‚ùå[/red]")

            files_to_process = [
                file for file in missing_files if file not in completed_files
            ]

            if not files_to_process:
                self.console.print("[green]‚úÖ ÊâÄÊúâÁº∫Â§±Êñá‰ª∂Â∑≤Â§ÑÁêÜÂÆåÊØï„ÄÇ")
                return

            self.console.print("\nü§î ÊòØÂê¶Ë¶ÅËΩ¨Êç¢Ëøô‰∫õÊñá‰ª∂? (y/n)", style="bold cyan")
            user_input = input().lower()

            if user_input != "y":
                self.console.print("‚ùå Êìç‰ΩúÂ∑≤ÂèñÊ∂à„ÄÇ", style="bold red")
                return
        else:
            self.console.print("[green]‚úÖ Ê≤°ÊúâÂèëÁé∞ÈÅóÊºèÁöÑÊñá‰ª∂„ÄÇ")
            return

        with self.progress:
            task = self.progress.add_task(
                "[cyan]üîç ÊØîÂØπÂπ∂ËΩ¨Êç¢Êñá‰ª∂...", total=len(files_to_process), filename=""
            )

            for file in files_to_process:
                source_file = os.path.join(source_folder, file)
                self.progress.update(task, filename=f"Ê≠£Âú®Â§ÑÁêÜ: {file}")
                self.convert(source_file, target_folder, _format)  # ÈªòËÆ§ËΩ¨Êç¢‰∏∫ markdown
                completed_files.append(file)
                self.save_task_state(task_id, completed_files)
                self.progress.advance(task)

        self.batch_mode = False
        self.console.print(
            f"[green]üéâ ÂÆåÊàêÊØîÂØπÂíåËΩ¨Êç¢„ÄÇÂÖ±Â§ÑÁêÜ {len(files_to_process)} ‰∏™Êñá‰ª∂„ÄÇ"
        )

    def unzip(self, zip_file_path, output_folder):
        try:
            file_name = os.path.basename(zip_file_path)
            with zipfile.ZipFile(zip_file_path, "r") as zip_ref:
                zip_ref.extractall(output_folder)
            if not self.batch_mode:
                self.console.print(
                    f"[green]ÊàêÂäüËß£ÂéãÊñá‰ª∂ {file_name} Âà∞ {output_folder}[/green]"
                )
            return True
        except Exception as e:
           
            self.console.print(f"[red]Ëß£ÂéãÊñá‰ª∂ {file_name} Êó∂Âá∫Èîô: {str(e)}[/red]")
            return False

    def rename(self, source_file):
        try:
            filename = os.path.basename(source_file)
            dirname = os.path.dirname(source_file)
            if (
                filename.endswith(".vtt")
                or filename.endswith(".srt")
                or filename.endswith(".ass")
            ):
                name, ext = os.path.splitext(filename)
                parts = name.split(".")

                lang_codes = [
                    part
                    for part in parts
                    if part in ["ENG", "CC", "FORCED", "CHS", "CHT", "Unknown", "SDH"]
                    or part.startswith(("en", "zh", "cmn", "yue"))
                ]

                if len(lang_codes) > 1 or "Unknown" in parts:
                    title = ".".join(
                        [
                            part
                            for part in parts
                            if part not in lang_codes and part != "Unknown"
                        ]
                    )
                    std_lang_code = ".".join(
                        [code for code in lang_codes if code != "Unknown"]
                    )
                    new_filename = f"{title}.{std_lang_code}{ext}"
                elif re.search(
                    r"\.(ENG\.CC|ENG\.FORCED|ENG\.SDH|ENG|CHS\.FORCED|CHS|CHT\.FORCED|CHT)$",
                    name,
                ):
                    if not self.batch_mode:
                        self.console.print(
                            f"[blue] Êñá‰ª∂ '{filename}' ÂêçÁß∞Â∑≤Ê†áÂáÜÂåñÔºåË∑≥Ëøá[/blue]"
                        )
                    return filename
                else:
                    lang_match = re.search(
                        r"(en(?:\[cc\]|-forced|-IN\[cc\]|-US|-GB)?|zh(?:-Hans|-Hant|-CN|-TW|-HK|-SG|-forced)?|cmn-(?:Hans|Hant)|yue-(?:Hans|Hant)|CHZ|ENG|CHS|CHT|CC|SDH)$",
                        name,
                    )
                    lang_code = lang_match.group(1) if lang_match else "Unknown"
                    title = re.sub(
                        r"\.(en(?:\[cc\]|-forced|-IN\[cc\]|-US|-GB)?|zh(?:-Hans|-Hant|-CN|-TW|-HK|-SG|-forced)?|cmn-(?:Hans|Hant)|yue-(?:Hans|Hant)|CHZ|ENG|CHS|CHT|CC|SDH)$",
                        "",
                        name,
                    )
                    title = re.sub(r"_+", ".", title)
                    title = re.sub(r"\.+", ".", title)
                    title = re.sub(r"\.(?:WEBRip|Netflix)", "", title)
                    lang_map = {
                        "en[cc]": "ENG",
                        "en-IN[cc]": "ENG",
                        "en-US": "ENG",
                        "en-GB": "ENG",
                        "zh-Hans": "CHS",
                        "zh-Hans-forced": "CHS",
                        "zh-Hant": "CHT",
                        "zh-Hant-forced": "CHT",
                        "zh-CN": "CHS",
                        "zh-TW": "CHT",
                        "zh-HK": "CHT",
                        "zh-SG": "CHS",
                        "zh": "CHS",
                        "cmn-Hans": "CHS",
                        "cmn-Hant": "CHT",
                        "yue-Hans": "CHS",
                        "yue-Hant": "CHT",
                        "en-forced": "ENG",
                        "en": "ENG",
                        "CHZ": "CHS",
                        "ENG": "ENG",
                        "CHS": "CHS",
                        "CHT": "CHT",
                        "CC": "CC",
                        "SDH": "SDH",
                    }
                    std_lang_code = lang_map.get(lang_code, "Unknown")
                    new_filename = f"{title}.{std_lang_code}{ext}"
                    os.rename(source_file, os.path.join(dirname, new_filename))

                if new_filename != filename:
                    if not self.batch_mode:
                        self.console.print(
                            f"[green]Â∞Ü'{filename}' ÈáçÂëΩÂêç‰∏∫ '{new_filename}'[/green]"
                        )
                    return new_filename
                else:
                    if not self.batch_mode:
                        self.console.print(f"[blue]Êñá‰ª∂ '{filename}' Êó†ÈúÄÈáçÂëΩÂêç[/blue]")
                    return filename
            else:
                if not self.batch_mode:
                    self.console.print(
                        f"[blue] Êñá‰ª∂ '{filename}' ‰∏çÊòØÂ≠óÂπïÊñá‰ª∂ÔºåË∑≥Ëøá[/blue]"
                    )
                return filename
        except Exception as e:
            if not self.batch_mode:
                self.console.print(f"[red] ÈáçÂëΩÂêçÊñá‰ª∂Êó∂Âá∫Èîô: {str(e)}[/red]")
            return filename

    def _get_title(self, source_file):
        try:
            # ‰ªéÊñá‰ª∂Âêç‰∏≠ÊèêÂèñÂèØËÉΩÁöÑÊ†áÈ¢ò
            filename = os.path.splitext(os.path.basename(source_file))[0]
            language = self._get_lang_code(filename)
            filename = filename.split(f".{language}")[0]
            title = filename.replace(".", " ")

            base_url = "https://api.themoviedb.org/3"
            movie_search_url = f"{base_url}/search/movie"
            movie_params = {
                "api_key": self.api_key,
                "query": title,
                "language": "zh-CN",
            }
            movie_response = requests.get(movie_search_url, params=movie_params)
            movie_data = movie_response.json()
            tv_search_url = f"{base_url}/search/tv"
            tv_params = {"api_key": self.api_key, "query": title, "language": "zh-CN"}
            tv_response = requests.get(tv_search_url, params=tv_params)
            tv_data = tv_response.json()

            if movie_data.get("results") and movie_data["results"][0]:
                chinese_title = movie_data["results"][0].get("title", "")
                original_title = movie_data["results"][0].get("original_title", "")
                if language == "CHS":
                    return chinese_title
                elif language == "CHT":
                    chinese_title = cc.convert(chinese_title)
                    return chinese_title
                elif language == "ENG":
                    return original_title
            elif tv_data.get("results") and tv_data["results"][0]:
                chinese_title = tv_data["results"][0].get("name", "")
                original_title = tv_data["results"][0].get("original_name", "")
                if language == "CHS" or language == "CHT":
                    return chinese_title
                elif language == "ENG":
                    return original_title
            else:
                return title.replace(".", " ")

        except Exception as e:
            self.console.print(f"[red]Ëé∑ÂèñÊ†áÈ¢òÊó∂Âá∫Èîô: {str(e)}[/red]")
            return title

    def _convert_charset(self, source_file: str):
        try:
            ext = os.path.splitext(source_file)[1]
            with open(source_file, "rb") as file:
                raw_data = file.read()
                result = chardet.detect(raw_data)
                source_encoding = result["encoding"]
            with open(source_file, "r", encoding=source_encoding) as sf:
                content = sf.read()

            with tempfile.NamedTemporaryFile(
                mode="w+", encoding="utf-8", delete=False, suffix=ext
            ) as temp_file:
                temp_file.write(content)
                if not self.batch_mode:
                    self.console.print(
                        f"[green]Â∑≤Â∞Ü {source_file} ÁºñÁ†Å {source_encoding} ËΩ¨Êç¢‰∏∫utf-8[/green]"
                    )
                return temp_file.name
        except Exception as e:
            if not self.batch_mode:
                self.console.print(f"[red]ËΩ¨Êç¢ÁºñÁ†ÅÊó∂Âá∫Èîô: {str(e)}[/red]")
            return ""

    def _convert_to_txt(self, source_file, target_path=None, temp=False):
        try:
            source_file = self._convert_charset(source_file)
            filename = f"{os.path.splitext(os.path.basename(source_file))[0]}.txt"
            file_extension = os.path.splitext(source_file)[1].lower()
            content = ""
            match file_extension:
                case ".vtt":
                    content = self._process_vtt(source_file)
                case ".srt":
                    content = self._process_srt(source_file)
                case ".ass":
                    content = self._process_ass(source_file)
                case _:
                    if not self.batch_mode:
                        self.console.print(
                            f"[red]‰∏çÊîØÊåÅÁöÑÊñá‰ª∂Ê†ºÂºè: {file_extension}[/red]"
                        )
                    return ""
            if temp:
                with tempfile.NamedTemporaryFile(
                    mode="w+", encoding="utf-8", delete=False, suffix=".txt"
                ) as temp_file:
                    temp_file.write(content)
                    if not self.batch_mode:
                        self.console.print(
                            f"[green]{source_file} ËΩ¨Êç¢‰∏∫txtÊàêÂäü[/green]"
                        )
                    return temp_file.name
            else:
                if not target_path:
                    target_file = filename
                else:
                    target_file = os.path.join(target_path, filename)
                with open(target_file, "w", encoding="utf-8") as txt_file:
                    txt_file.write(content)
                    if not self.batch_mode:
                        self.console.print(
                            f"[green]{source_file} ËΩ¨Êç¢‰∏∫txtÊàêÂäü[/green]"
                        )
                    return target_file
        except Exception as e:
            if not self.batch_mode:
                self.console.print(
                    f"[red]Â§ÑÁêÜÊñá‰ª∂ '{os.path.basename(source_file)}' Êó∂Âá∫Èîô: {str(e)}[/red]"
                )
            return ""

    def _process_vtt(self, source_file):
        try:
            
            content = ""
            for caption in webvtt.read(source_file):
                clean_text = self._clean_text(caption.text)
                if clean_text:
                    content += clean_text + "\n"
            return content
        except Exception as e:
            self.console.print(
                f"[red]Â§ÑÁêÜ VTT Êñá‰ª∂ '{os.path.basename(source_file)}' Êó∂Âá∫Èîô: {str(e)}[/red]"
            )
            return ""

    def _process_srt(self, source_file):
        try:
            subs = pysrt.open(source_file, encoding="utf-8")
            content = ""
            for sub in subs:
                clean_text = self._clean_text(sub.text)
                if clean_text:
                    content += clean_text + "\n"
            return content
        except Exception as e:
            self.console.print(
                f"[red]Â§ÑÁêÜ SRT Êñá‰ª∂ '{os.path.basename(source_file)}' Êó∂Âá∫Èîô: {str(e)}[/red]"
            )
            return ""

    def _process_ass(self, source_file):
        try:
            content = ""
            with open(source_file, encoding="utf-8") as ass_file:
                ass_data = ass.parse(ass_file)
            for event in ass_data.events:
                clean_text = self._clean_text(event.text)
                if clean_text:
                    content += clean_text + "\n"
            return content
        except Exception as e:
           
            self.console.print(
                f"[red]Â§ÑÁêÜ ASS Êñá‰ª∂ '{os.path.basename(source_file)}' Êó∂Âá∫Èîô: {str(e)}[/red]"
            )
            return ""

    def _clean_text(self, text):
        # ÁßªÈô§HTMLÂÆû‰ΩìÂíåÊ†áÁ≠æ
        clean_text = html.unescape(text)
        clean_text = re.sub(r"<[^>]+>", "", clean_text)
        # ÁßªÈô§UnicodeÊéßÂà∂Â≠óÁ¨¶ÔºåÂåÖÊã¨LRM (U+200E)ÂíåRLM (U+200F)
        clean_text = re.sub(r"[\u200E\u200F]", "", clean_text)
        # ÁßªÈô§ÂÖ∂‰ªñÂèØËÉΩÁöÑÁâπÊÆäÂ≠óÁ¨¶ÂíåÁ©∫ÁôΩ
        clean_text = clean_text.strip()
        return clean_text

    def _convert_to_markdown(self, source_file, target_path=None, temp=False):
        txt_file = self._convert_to_txt(source_file, temp=True)
        filename = f"{os.path.splitext(os.path.basename(source_file))[0]}.md"
        if txt_file is None:
            return
        with open(txt_file, "r", encoding="utf-8") as txt:
            lines = txt.readlines()
            content = "".join([f"{line.strip()}  \n" for line in lines])

        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        title = self._get_title(source_file)
        markdown_content = MarkdownTemplate.render(
            {"title": title, "timestamp": timestamp, "content": content}
        )
        if temp:
            with tempfile.NamedTemporaryFile(
                delete=False, suffix=".md"
            ) as temp_md_file:
                temp_md_file.write(markdown_content.encode("utf-8"))
                if not self.batch_mode:
                    self.console.print(
                        f"[green]{source_file} ËΩ¨Êç¢‰∏∫markdownÊàêÂäü[/green]"
                    )
                return temp_md_file.name
        else:
            if not target_path:
                target_file = filename
            else:
                target_file = os.path.join(target_path, filename)
            with open(target_file, "w", encoding="utf-8") as md_file:
                md_file.write(markdown_content)
                if not self.batch_mode:
                    self.console.print(
                        f"[green]{source_file} ËΩ¨Êç¢‰∏∫markdownÊàêÂäü[/green]"
                    )
                return target_file

    def _convert_to_docx(self, source_file, target_path=None):
        filename = f"{os.path.splitext(os.path.basename(source_file))[0]}.docx"
        markdown_temp = self._convert_to_markdown(source_file, temp=True)
        if not markdown_temp:
            return

        if not target_path:
            target_file = filename
        else:
            target_file = os.path.join(target_path, filename)
        try:
            pypandoc.convert_file(
                markdown_temp,
                "docx",
                outputfile=target_file,
                extra_args=[
                    f"--reference-doc={os.path.join(self.template_path, 'template.docx')}"
                ],
                encoding="utf-8",
            )
            if not self.batch_mode:
                self.console.print(f"[green]{source_file} ËΩ¨Êç¢‰∏∫docxÊàêÂäü[/green]")
        finally:
            os.unlink(markdown_temp)

        return target_file

    def _convert_to_html(self, source_file, target_path=None, temp=False):
        txt_file = self._convert_to_txt(source_file, temp=True)
        filename = f"{os.path.splitext(os.path.basename(source_file))[0]}.html"
        if txt_file is None:
            return
        with open(txt_file, "r", encoding="utf-8") as txt_file:
            lines = txt_file.readlines()
            content = "".join([f"<p> {line.strip()} </p>" for line in lines])
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        title = self._get_title(source_file)
        html_content = HTMLTemplate.render(
            {"title": title, "timestamp": timestamp, "content": content}
        )
        if temp:
            with tempfile.NamedTemporaryFile(
                mode="w+", encoding="utf-8", delete=False, suffix=".html"
            ) as temp_file:
                temp_file.write(html_content)
                if not self.batch_mode:
                    self.console.print(f"[green]{source_file} ËΩ¨Êç¢‰∏∫htmlÊàêÂäü[/green]")
                return temp_file.name
        else:
            if not target_path:
                target_file = filename
            else:
                target_file = os.path.join(target_path, filename)
            with open(target_file, "w", encoding="utf-8") as html_file:
                html_file.write(html_content)
                if not self.batch_mode:
                    self.console.print(f"[green]{source_file} ËΩ¨Êç¢‰∏∫htmlÊàêÂäü[/green]")
                return target_file

    def _convert_to_pdf(self, source_file: str, target_path=None):
        filename = os.path.splitext(os.path.basename(source_file))[0]
        co = ChromiumOptions(read_file=False)
        co.set_paths(browser_path=self.chrome_path)
        co.headless(True)
        co.auto_port()
        page = ChromiumPage(addr_or_opts=co)
        html_temp = self._convert_to_html(source_file, temp=True)

        try:
            target_file = os.path.join(target_path, filename)
            page.get(f"file://{os.path.abspath(html_temp)}")
            main = page.ele("tag:main")
            main.wait.displayed()
            page.save(
                path=target_path if target_path else ".",
                name=filename,
                as_pdf=True,
                generateTaggedPDF=True,
                generateDocumentOutline=True,
                displayHeaderFooter=True,
                headerTemplate="<div></div>",
                footerTemplate='<div style="width:100%; text-align:center; font-size:10px;"><span class="pageNumber"></span>&nbsp;/&nbsp;<span class="totalPages"></span></div>',
            )
        except Exception as e:
            self.console.print(f"[red]ËΩ¨Êç¢PDFÊó∂Âá∫Èîô: {str(e)}[/red]")
            return ""
        finally:
            page.quit()
            os.unlink(html_temp)
        return target_file

    def convert(self, source_file, target_path=None, _format=None):
        if _format is None:
            _format = "md"
        try:
            match _format:
                case "md":
                    self._convert_to_markdown(source_file, target_path)
                case "docx":
                    self._convert_to_docx(source_file, target_path)
                case "html":
                    self._convert_to_html(source_file, target_path)
                case "pdf":
                    self._convert_to_pdf(source_file, target_path)
                case "txt":
                    self._convert_to_txt(source_file, target_path)
                case _:
                    if not self.batch_mode:
                        self.console.print(f"[red]‰∏çÊîØÊåÅÁöÑÊñá‰ª∂Ê†ºÂºè: {_format}[/red]")
            if not self.batch_mode:
                self.console.print(f"ÊàêÂäüÂ∞Ü {source_file} ËΩ¨Êç¢‰∏∫ {_format}")
        except Exception as e:
            self.console.print(f"[red]ËΩ¨Êç¢Êñá‰ª∂ {source_file} Êó∂Âá∫Èîô: {str(e)}")

    def clean(self, input_folder, resume=False):
        self.batch_mode = True
        task_id = "clean"
        completed_folders = self.load_task_state(task_id) if resume else []

        with self.progress:
            task = self.progress.add_task(
                "[magenta]üßπ Ê∏ÖÁêÜÊñá‰ª∂...", total=1, filename=""
            )

            if input_folder in completed_folders:
                self.progress.update(task, advance=1)
                return

            self.progress.update(
                task, filename=f"[magenta]Ê≠£Âú®Â§ÑÁêÜ: {input_folder}[/magenta]"
            )

            files = [
                f
                for f in os.listdir(input_folder)
                if os.path.isfile(os.path.join(input_folder, f))
            ]
            groups = defaultdict(list)

            for file in files:
                name, ext = os.path.splitext(file)
                base_name = re.sub(r"\.(CHS|CHT|ENG|CC|FORCED|SDH).*$", "", name)
                groups[base_name].append(file)

            for base_name, group in groups.items():
                if len(group) > 1:
                    self._clean_group(input_folder, group)

            completed_folders.append(input_folder)
            self.save_task_state(task_id, completed_folders)
            self.progress.update(task, advance=1)

        self.batch_mode = False

    def _clean_group(self, folder, group):
        lang_files = {"CHS": [], "CHT": [], "ENG": [], "Unknown": []}

        for file in group:
            lang = self._get_lang_code(file)
            lang_files[lang].append(file)

        for lang, files in lang_files.items():
            if files:
                # ‰øùÁïôÊØèÁßçËØ≠Ë®Ä‰∏≠ÊúÄÂ§ßÁöÑÊñá‰ª∂
                largest_file = max(
                    files, key=lambda f: os.path.getsize(os.path.join(folder, f))
                )
                for file in files:
                    if file != largest_file:
                        os.remove(os.path.join(folder, file))
                        self.console.print(f"[red]Âà†Èô§Êñá‰ª∂: {file}[/red]")

    def _get_lang_code(self, filename):
        match = re.search(r"\.(CHS|CHT|ENG)", filename)
        return match.group(1) if match else "Unknown"


def main():
    console = Console()
    console.print(banner)
    console.print("üëã Ê¨¢Ëøé‰ΩøÁî®Â≠óÂπïÂ∑•ÂÖ∑ÁÆ± CLI", style="bold blue")
    console.print("‚ùì ‰ΩøÁî® -h Êàñ --help Êü•ÁúãÂ∏ÆÂä©‰ø°ÊÅØ\n", style="bold blue")
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(dest="action")

    # Ëß£ÂéãÂëΩ‰ª§
    unzip_parser = subparsers.add_parser("unzip", aliases=["u"], help="ÊâπÈáèËß£ÂéãÊñá‰ª∂")
    unzip_parser.add_argument(
        "-i", "--input", nargs="+", required=True, help="ËæìÂÖ•zipÊñá‰ª∂ÊàñÁõÆÂΩï"
    )
    unzip_parser.add_argument("-o", "--output", required=True, help="ËæìÂá∫ÁõÆÂΩï")
    unzip_parser.add_argument("-r", "--resume", action="store_true", help="Êñ≠ÁÇπÁª≠‰º†")

    # ËΩ¨Êç¢ÂëΩ‰ª§
    convert_parser = subparsers.add_parser(
        "convert", aliases=["co"], help="ÊâπÈáèËΩ¨Êç¢Êñá‰ª∂"
    )
    convert_parser.add_argument(
        "-i", "--input", nargs="+", required=True, help="ËæìÂÖ•Êñá‰ª∂ÊàñÁõÆÂΩï"
    )
    convert_parser.add_argument("-o", "--output", required=True, help="ËæìÂá∫ÁõÆÂΩï")
    convert_parser.add_argument(
        "-f",
        "--format",
        choices=["md", "docx", "html", "pdf", "txt"],
        default="md",
        help="ËΩ¨Êç¢Ê†ºÂºè",
    )
    convert_parser.add_argument("-r", "--resume", action="store_true", help="Êñ≠ÁÇπÁª≠‰º†")

    # ÈáçÂëΩÂêçÂëΩ‰ª§
    rename_parser = subparsers.add_parser(
        "rename", aliases=["r"], help="ÊâπÈáèÈáçÂëΩÂêçÊñá‰ª∂"
    )
    rename_parser.add_argument(
        "-i", "--input", nargs="+", required=True, help="ËæìÂÖ•Êñá‰ª∂ÊàñÁõÆÂΩï"
    )
    rename_parser.add_argument("-r", "--resume", action="store_true", help="Êñ≠ÁÇπÁª≠‰º†")

    # Ê∏ÖÁêÜÂëΩ‰ª§
    clean_parser = subparsers.add_parser(
        "clean", aliases=["cl"], help="Ê∏ÖÁêÜÈáçÂ§çÁöÑÂ≠óÂπïÊñá‰ª∂"
    )
    clean_parser.add_argument("-i", "--input", required=True, help="ËæìÂÖ•ÁõÆÂΩï")
    clean_parser.add_argument("-r", "--resume", action="store_true", help="Êñ≠ÁÇπÁª≠‰º†")

    # ÊØîÂØπÂëΩ‰ª§
    diff_parser = subparsers.add_parser(
        "diff", aliases=["d"], help="ÊØîÂØπÂπ∂ËΩ¨Êç¢Áº∫Â§±ÁöÑÂ≠óÂπïÊñá‰ª∂"
    )
    diff_parser.add_argument("-i", "--input", required=True, help="ËæìÂÖ•ÁõÆÂΩï")
    diff_parser.add_argument("-o", "--output", required=True, help="ËæìÂá∫ÁõÆÂΩï")
    diff_parser.add_argument(
        "-f",
        "--format",
        choices=["md", "docx", "html", "pdf", "txt"],
        default="md",
        help="ËΩ¨Êç¢Ê†ºÂºè",
    )
    diff_parser.add_argument("-r", "--resume", action="store_true", help="Êñ≠ÁÇπÁª≠‰º†")

    args = parser.parse_args()

    toolbox = Toolbox()

    try:
        if args.action in ["unzip", "u"]:
            zip_files = []
            for input_path in args.input:
                if os.path.isdir(input_path):
                    zip_files.extend(
                        [
                            os.path.join(input_path, f)
                            for f in os.listdir(input_path)
                            if f.endswith(".zip")
                        ]
                    )
                else:
                    zip_files.append(input_path)
            toolbox.batch_unzip(zip_files, args.output, args.resume)
        elif args.action in ["convert", "co"]:
            source_files = []
            for input_path in args.input:
                if os.path.isdir(input_path):
                    source_files.extend(
                        [
                            os.path.join(input_path, f)
                            for f in os.listdir(input_path)
                            if f.endswith((".vtt", ".srt", ".ass"))
                        ]
                    )
                else:
                    source_files.append(input_path)
            toolbox.batch_convert(source_files, args.output, args.format, args.resume)
        elif args.action in ["rename", "r"]:
            toolbox.batch_rename(args.input, args.resume)
        elif args.action in ["clean", "cl"]:
            toolbox.clean(args.input, args.resume)
        elif args.action in ["diff", "d"]:
            toolbox.diff(args.input, args.output, args.format, args.resume)
    except KeyboardInterrupt:
        console.print("\nüëã Á®ãÂ∫èÂ∑≤ÈÄÄÂá∫ÔºåByeÔºÅ", style="bold yellow")
    except Exception as e:
        console.print(f"\n‚ùå ÂìéÂëÄÔºåÂá∫Èîô‰∫Ü: {str(e)}", style="bold red")
    finally:
        if not args.action:
            parser.print_help()
        else:
            console.print("\nüëã ByeÔºÅ", style="bold blue")


if __name__ == "__main__":
    main()
